<body>
<h2>Proposal for the Agile Development of gus
through the use of Scrums</h2>
Leah Wegner<br><br>
Colby Blair<br><br>
Alex Nilson<br><br>
Tim Biochetti<br><br>
CS-383 -- Dr. Jeffery<br>
October 26, 2010<br><br>
<h3>Summary</h3><br>
The gus project group will develop using scrums within the agile software development environment. This helps account for some of the issues that arise from development inside the classroom environment, where we are unsure what can and cannot be accomplished in a given amount of time, and have a specific deadline whether the project is at a "stopping place" or not.<br><br>

<h3>Background</h3>
Agile development was designed to help get the priorities straight in the software development world. The main idea is to show that the customers and people you work with are more important than following any sort of pre-determined plan, and that, in the end, what the customer really cares about is that the final software does what they want it to, instead of any sort of "over comprehensive documentation."<br>
The agile development strategy attempts to accomplish this through iterative development, where the core of the project is created first, and although it might not seem very functional, it will have the potential of adding on functionality as the design process continues. The most comprehensive and popular way to do this is to use scrums. This is because of the fulfillment of the basic iterative function necessary to the agile strategy, as well as an easy way for the workers to measure their productivity, and know when they are falling behind schedule. Also, it is possible for the workers to change the schedule if necessary, to account for unforeseen challenges and difficulties.<br>
While it might not be as effective in a classroom environment as it would in a real work place, it still seems possible. This is because although we are all students, and do not have as much time to put into the gus project as might be necessary to get it finished and to completion. With the agile scrum method, it would be easier to simply make enough iterations to fill the semester and see how far we get, where as with other software development models, if one person gets behind, it is likely that the whole project will suffer because of it, due to a lack of emphasis on communication. <br><br>

<h3>Schedule</h3>
Due to the nature of the development in the classroom development, we need to be careful of how we manage the time for the scrums. It is necessary that we identify the core of the gus program and complete it before moving on to the other, less core functionalities. That way, even it the program does not work to the exact specifications of the customer, then it can be delivered in at least a semi-functional form.<br>
We will be doing bi-weekly scrum cycles, thus allowing for in classroom feedback during each cycle of development. In a semester, there are 11 weeks, so, in order to accommodate for unplanned class cancelation, we will be doing five scrum cycles, although the length of the meetings, and the amount that will actually be accomplished during each cycle will need to be cut down quite a bit due to the development environment.<br>
Maximizing productivity of about 20 people on a software project of about 15 weeks means that everyone
needs to also have something to work on. It is unclear if the 5 subgroups would remain so through the
coding portion of the project, but either way, the project will need substantial HR management without
too much management. Enough so to delegate work constantly and to be able to gauge and adjust work due to
deadlines. Our group feels that with Scrum as a major framework, and F/TDD and others implemented where
it makes sense, the process can be as productive as possible. FDD alone is not enough management
structure to assist us, but seems to fit in well as a subset of a larger, logical system.
<br><br>


<h4>Cycle 1:</h4>
During this cycle, we will get the core of the program completed and working. This includes the objects that will represent the users and groups, structures for saving the information provided about users and groups, and the basic creation, deletion, and editing functions for groups and user accounts. This is the core of the gus program, without which, all other functionality will be meaningless.<br><br>

<h4>Cycle 2:</h4>
During this cycle, we will focus on the use cases related to the system administration of a gus server. These use cases include log functions, time-stamp checking, server syncing, and the setup of an initial gus group, and leader for that group.<br><br>

<h4>>Cycle 3:</h4>
During this cycle, we will focus on a GUI and the concept of user privileges and creation and delegation of subgroups. While it is possible that this could be accomplished in cycle 1, it is necessary to check that it works the way it is supposed to, and set up a user interface to build off of. This will be a potential time to ask the customer for feedback, however, at this point, it seems unlikely that there will be much that they can say.<br><br>

<h4>Cycle 4:</h4>
This cycle will be devoted to the expansion of functionality. Each subgroup will become responsible for different portions of the functionality. The main sections that need to be considered at this point will include the calendar, the email functions, the forums, the wiki style web pages, and support for html input of web page code. This will also be the first large scale test that will be conducted, including a temporary gus server and users. Customer feedback will also be sought after.<br><br>

<h4>Cycle 5:</h4>
This cycle will be allotted for the creation of more group-specific use case requirements. We will make functions to do things like enter math formulas, and allow people to rsvp to calendar events with limited space. There will also be time to finish creating functionality of the use cases from cycle 4, as well as refine the user interface, to make it easier to use by someone who had not worked on the project itself.<br><br>

<h4>Cycle 5.5 (week 11):</h4>
If time allows, the final week of the semester will be used to revise the program as a whole and decide how we could have performed better. This is to allow for feedback from everyone in the class. This is, after all, supposed to be a learning experience. Also, if a deliverable program is actually produced, this would be an opportunity to go to the customers who we talked to earlier this semester, and see how gus lived up to their expectations.<br><br>

<h3>Cycle Detail</h3>
<ul>
<li>Stages
 <ul>
  <li>Plan
   <ul>
    <li>Model/conceptualize the structure and functionality of the software (Agile Modeling)</li>
    <li>Project Management (AUP)
     <ul>
      <li>Division of Labor</li>
      <li>Milestones (FDD)</li>
     </ul>
    </li>
   </ul>
  </li>
 <li>Prototype
  <ul><li>Model software (AUP)</li></ul>
 </li>
 <li>Implement/Develop
  <ul>
   <li>Pair Programming per Planning stage (Extreme Programming)</li>
   <li>Implement (AUP)</li>
   <li>Deployment (AUP)</li>
   <li>Configuration Management</li>
  </ul>
 </li>
 <li>Test and Next Sprint Planning
  <ul>
   <li>Testing (AUP)</li>
   <li>Environment (AUP)</li>
   <li>Spring Review Meeting
    <ul><li>Random Code Reviews</li></ul>
   </li>
  </ul>
 </li>
</ul>
</li>

<h3>Design and Management Goals</h3>
<li>The software be developed as an MVC or some sort of entity-boundary-control to fit the development process and the Agile Spiral stages as closely as possible.
</li><li>Constant testing in development as often at makes sense (i.e. completion of each function?) (DSDM)
</li><li>The process stays as simple as possible, from planning all the way through to testing. (AUP, Extreme Programming)
</li><li>Scrum sprints occur every 2 weeks to allow enough time for work, but enough iterations to see whether progress is being made. (Scrum, AUP)
</li><li>Tool independence, meaning we should use unit testing and any necessary aides that are written in / specialize in the languages and frameworks we will use (Java uses junit, php uses phpunit, etc) (AUP)
</li><li>Delivery of working product by the end of every Scrum sprint (Scrum, DSDM)

</li><li>Git is used, and developers use it as best as they can to make changes reversible (DSDM)
</li><li>Scrum Master and Managers assign pair programming or let team members volunteer when it seems beneficial. It shouldn't be something we do only if we feel like, but something we make a point to do as a requirement. (Extreme Programming)
</li><li>Random Code Reviews are done in Sprint Review meetings. Everyone needs to be involved in the process. (Extreme Programming)
</li><li>The ACM Code of Ethics [2] is adhered to, as well as the Interpersonal Communications Rules of Engagement outlined by Dr. Jeffery. Everyone needs involvement in the entire process to make the boat float.
</li></ul>

</body>
